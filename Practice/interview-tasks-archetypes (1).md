# Архетипы задач для Java собеседований

## 1. Задачи на Stream API

### Структура архетипичной задачи

```
Дана коллекция объектов: List<Entity>
Требуется: выполнить операции фильтрации/группировки/преобразования
Результат: новая структура данных или агрегированное значение
```

### Уровни сложности

#### Уровень 1-2 (Junior)
**Паттерн**: Простая цепочка операций
- filter() по одному условию
- map() для преобразования типа
- collect() в List или Set

**Шаблон задачи**:
```java
// Дано
List<Person> persons = List.of(
    new Person("Иван", 25, "Москва"),
    new Person("Петр", 30, "СПб"),
    new Person("Анна", 22, "Москва")
);

// Задание: получить имена всех людей старше 23 лет
// Ожидаемый результат: ["Иван", "Петр"]
```

#### Уровень 3 (Middle-)
**Паттерн**: Группировка и агрегация
- groupingBy() с downstream коллекторами
- partitioningBy()
- Вложенные map операции
- flatMap() для разворачивания коллекций

**Шаблон задачи**:
```java
// Дано
List<Department> departments = List.of(
    new Department("IT", List.of(
        new Employee("Иван", 100000),
        new Employee("Петр", 120000)
    )),
    new Department("HR", List.of(
        new Employee("Анна", 80000)
    ))
);

// Задание: найти департамент с максимальной средней зарплатой
// Дополнительно: вывести Map<String, Double> - департамент -> средняя зп
```

#### Уровень 4-5 (Middle+/Senior)
**Паттерн**: Сложные преобразования и custom collectors
- Параллельные стримы с учетом thread-safety
- reduce() для кастомной агрегации
- Собственные Collector implementations
- Оптимизация производительности

**Шаблон задачи**:
```java
// Дано
List<Transaction> transactions = loadMillionTransactions();

// Задание: 
// 1. Найти топ-10 клиентов по сумме транзакций за последний месяц
// 2. Для каждого клиента вывести статистику по типам транзакций
// 3. Обработать параллельно с учетом thread-safety
// 4. Оптимизировать для больших данных
```

### Ключевые элементы для генерации

1. **Исходные данные**: 
   - Простые объекты (Person, Product, Order)
   - Вложенные структуры (Department -> Employee)
   - Связанные данные (Order -> OrderItem)

2. **Операции**:
   - Фильтрация по условиям
   - Преобразование типов
   - Группировка по полям
   - Агрегация (sum, avg, max, min, count)
   - Сортировка
   - Ограничение выборки (limit, skip)

3. **Результаты**:
   - List/Set простых типов
   - Map с группировкой
   - Optional для поиска
   - Статистика (IntSummaryStatistics)
   - Кастомные DTO

## 2. Задачи на SQL

### Структура архетипичной задачи

```
Дано: схема из 2-4 связанных таблиц
Требуется: написать запрос для получения данных
Особенности: JOIN, GROUP BY, подзапросы, оконные функции
```

### Уровни сложности

#### Уровень 1-2 (Junior)
**Паттерн**: Простые выборки и JOIN
```sql
-- Таблицы
users (id, name, city_id)
cities (id, name)

-- Типовые задания:
-- 1. Выбрать всех пользователей из Москвы
-- 2. Подсчитать количество пользователей по городам
-- 3. Найти города без пользователей
```

#### Уровень 3 (Middle-)
**Паттерн**: GROUP BY с HAVING, подзапросы
```sql
-- Таблицы
employees (id, name, department_id, salary, hire_date)
departments (id, name, manager_id)

-- Типовые задания:
-- 1. Найти департаменты со средней зп > 100000
-- 2. Вывести сотрудников, чья зп выше средней по департаменту
-- 3. Найти дубликаты по составному ключу
```

#### Уровень 4-5 (Middle+/Senior)
**Паттерн**: Оконные функции, CTE, сложная аналитика
```sql
-- Таблицы
orders (id, customer_id, date, status, amount)
order_items (id, order_id, product_id, quantity, price)
products (id, name, category_id)

-- Типовые задания:
-- 1. Ранжировать клиентов по сумме покупок с разбивкой по месяцам
-- 2. Найти товары, продажи которых растут 3 месяца подряд
-- 3. Рекурсивный запрос для иерархической структуры
```

### Ключевые элементы для генерации

1. **Схемы данных**:
   - Пользователи и их атрибуты
   - Заказы и товары (e-commerce)
   - Сотрудники и департаменты (HR)
   - Транзакции и счета (финансы)

2. **SQL конструкции**:
   - JOIN (INNER, LEFT, RIGHT, FULL)
   - GROUP BY + агрегатные функции
   - HAVING для фильтрации групп
   - Подзапросы (в SELECT, FROM, WHERE)
   - UNION, INTERSECT, EXCEPT
   - Оконные функции (ROW_NUMBER, RANK, LAG/LEAD)
   - CTE (WITH clause)

3. **Типовые задачи**:
   - Поиск дубликатов
   - Топ-N в каждой группе
   - Сравнение с агрегированными значениями
   - Анализ временных рядов
   - Работа с иерархиями

## 3. Задачи "Что выведет этот код?"

### Структура архетипичной задачи

```
Дан код: 10-30 строк Java кода
Вопрос: Что будет выведено в консоль?
Подвох: неочевидное поведение Java
```

### Уровни сложности

#### Уровень 1-2 (Junior)
**Паттерны**:
- String pool и сравнение строк
- Автобоксинг и кеширование Integer
- Порядок инициализации классов
- Переопределение методов

**Шаблон**:
```java
public class Main {
    public static void main(String[] args) {
        String s1 = "hello";
        String s2 = "hello";
        String s3 = new String("hello");
        
        System.out.println(s1 == s2);      // ?
        System.out.println(s1 == s3);      // ?
        System.out.println(s1.equals(s3)); // ?
    }
}
```

#### Уровень 3 (Middle-)
**Паттерны**:
- Наследование и статические методы
- Исключения в finally блоке
- Изменяемость коллекций
- Stream операции и lazy evaluation

**Шаблон**:
```java
public class Main {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("a", "b", "c");
        Stream<String> stream = list.stream();
        list.add("d"); // ?
        stream.forEach(System.out::println);
    }
}
```

#### Уровень 4-5 (Middle+/Senior)
**Паттерны**:
- Многопоточность и race conditions
- Транзакции и proxy в Spring
- Generics и type erasure
- ClassLoader и инициализация

**Шаблон**:
```java
public class Main {
    private static int counter = 0;
    
    public static void main(String[] args) throws InterruptedException {
        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter++;
            }
        };
        
        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        
        System.out.println(counter); // ?
    }
}
```

### Ключевые Java особенности для задач

1. **String и примитивы**:
   - String pool и intern()
   - Integer cache (-128 до 127)
   - Автобоксинг/анбоксинг

2. **Коллекции**:
   - Arrays.asList() возвращает fixed-size list
   - ConcurrentModificationException
   - HashMap и null ключи/значения

3. **ООП**:
   - Порядок вызова конструкторов
   - Статические методы не переопределяются
   - Приватные методы и наследование

4. **Исключения**:
   - finally всегда выполняется
   - return в finally перезаписывает return в try
   - Checked vs Unchecked

5. **Многопоточность**:
   - volatile и visibility
   - synchronized и deadlock
   - Atomic операции

## 4. Задачи на рефакторинг кода

### Структура архетипичной задачи

```
Дан код: 20-50 строк с проблемами
Задание: найти проблемы и предложить улучшения
Фокус: best practices, паттерны, производительность
```

### Уровни сложности

#### Уровень 1-2 (Junior)
**Типовые проблемы**:
- Нарушение naming conventions
- Дублирование кода
- Неиспользуемые переменные
- Отсутствие проверок на null
- Публичные поля вместо геттеров

**Шаблон проблемного кода**:
```java
public class user {
    public String Name;
    public int age;
    
    public void processUser(String name) {
        Name = name;
        // дублирование логики
        if (age > 18) {
            System.out.println("Adult");
        }
        if (age > 65) {
            System.out.println("Senior");
        }
    }
}
```

#### Уровень 3 (Middle-)
**Типовые проблемы**:
- Нарушение SOLID принципов
- Неправильная обработка исключений
- Проблемы с транзакциями
- SQL injection
- Resource leaks

**Шаблон проблемного кода**:
```java
@Service
public class UserService {
    @Autowired
    private JdbcTemplate jdbc;
    
    @Transactional
    public void updateUser(String id, String name) {
        try {
            jdbc.execute("UPDATE users SET name = '" + name + "' WHERE id = " + id);
            sendNotification(id); // внешний сервис
        } catch (Exception e) {
            // пустой catch
        }
    }
}
```

#### Уровень 4-5 (Middle+/Senior)
**Типовые проблемы**:
- Архитектурные антипаттерны
- Проблемы производительности
- Thread safety issues
- Неправильное использование паттернов
- Сложность тестирования

**Шаблон проблемного кода**:
```java
@Service
@Scope("prototype")
public class ReportService {
    private List<Report> cache = new ArrayList<>();
    
    @Async
    @Transactional
    public CompletableFuture<Report> generateReport(List<Long> userIds) {
        // множественные проблемы:
        // - состояние в prototype bean
        // - @Transactional с @Async
        // - N+1 проблема
        // - отсутствие батчинга
        
        for (Long id : userIds) {
            User user = userRepo.findById(id);
            for (Order order : user.getOrders()) {
                // загрузка связанных данных в цикле
            }
        }
    }
}
```

### Категории проблем для генерации

1. **Code style**:
   - Naming (camelCase, constants)
   - Форматирование и читаемость
   - Комментарии и документация

2. **Best practices**:
   - DRY (Don't Repeat Yourself)
   - KISS (Keep It Simple)
   - YAGNI (You Ain't Gonna Need It)
   - Избыточная сложность

3. **ООП и паттерны**:
   - Нарушение инкапсуляции
   - Неправильное наследование
   - Антипаттерны (God Object, Anemic Model)

4. **Производительность**:
   - N+1 запросы
   - Отсутствие кеширования
   - Неэффективные алгоритмы
   - Memory leaks

5. **Безопасность**:
   - SQL/XSS injection
   - Хардкод credentials
   - Отсутствие валидации

6. **Spring специфика**:
   - Неправильные scope
   - Циклические зависимости
   - @Transactional подводные камни
   - Proxy ограничения

## 5. Алгоритмические задачи

### Структура архетипичной задачи

```
Дано: входные данные (массив, строка, граф)
Найти/Вычислить: результат по определенному алгоритму
Ограничения: время O(n), память O(1)
```

### Уровни сложности

#### Уровень 1-2 (Junior)
**Паттерны**:
- Линейный поиск
- Простые преобразования
- Работа с индексами
- Базовая математика

**Типовые задачи**:
```java
// 1. Реверс строки/массива
// Input: "hello" → Output: "olleh"

// 2. Поиск максимума/минимума
// Input: [3,5,1,9,2] → Output: 9

// 3. Подсчет элементов
// Input: "aabbbcc" → Output: {a:2, b:3, c:2}

// 4. Проверка палиндрома
// Input: "racecar" → Output: true
```

#### Уровень 3 (Middle-)
**Паттерны**:
- Two pointers
- Sliding window
- Hash map для оптимизации
- Простая рекурсия
- Базовые структуры данных

**Типовые задачи**:
```java
// 1. Two Sum и вариации
// Input: nums=[2,7,11,15], target=9 → Output: [0,1]

// 2. Удаление дубликатов с сохранением порядка
// Input: [1,3,3,5,5,7,7,7] → Output: [1,3,5,7]

// 3. Первый неповторяющийся элемент
// Input: [1,2,3,2,1,4,4] → Output: 3

// 4. Valid parentheses
// Input: "({[]})" → Output: true
```

#### Уровень 4-5 (Middle+/Senior)
**Паттерны**:
- Dynamic programming
- Сложные структуры (Tree, Graph)
- Оптимизация времени/памяти
- Несколько указателей
- Комбинация алгоритмов

**Типовые задачи**:
```java
// 1. Слияние отсортированных массивов in-place
// 2. Поиск цикла в связном списке
// 3. LRU Cache implementation
// 4. Поиск подмассива с максимальной суммой
// 5. Топологическая сортировка
```

### Ключевые алгоритмические паттерны

1. **Работа с массивами**:
   - Сортировка и бинарный поиск
   - Разворот и сдвиг элементов
   - Поиск пар/троек с условием
   - Слияние и пересечение

2. **Работа со строками**:
   - Поиск подстроки
   - Анаграммы и перестановки
   - Паттерн matching
   - Кодирование/декодирование

3. **Хеш-таблицы**:
   - Частотный анализ
   - Поиск за O(1)
   - Группировка элементов
   - Кеширование результатов

4. **Связные списки**:
   - Разворот списка
   - Поиск середины
   - Обнаружение цикла
   - Слияние списков

5. **Стек/Очередь**:
   - Валидация скобок
   - Обратная польская нотация
   - Sliding window maximum
   - BFS/DFS обход

## Рекомендации по генерации задач

### Формула создания задачи

1. **Выберите уровень сложности** (1-5)
2. **Выберите категорию** и соответствующий паттерн
3. **Создайте контекст**:
   - Бизнес-домен (e-commerce, banking, social)
   - Реалистичные данные
   - Понятные названия

4. **Добавьте подводные камни**:
   - Edge cases (null, empty, границы)
   - Performance considerations
   - Типичные ошибки

5. **Определите критерии оценки**:
   - Correctness (работает ли?)
   - Efficiency (оптимально ли?)
   - Code quality (читаемо ли?)
   - Best practices (следует ли стандартам?)

### Примеры комбинирования

**Stream API + SQL ментальность**:
"Есть таблица транзакций. Напишите Stream API запрос, который выполнит ту же логику, что и данный SQL"

**Алгоритм + Рефакторинг**:
"Дан рабочий, но неоптимальный код. Улучшите алгоритмическую сложность"

**Что выведет + Многопоточность**:
"Предскажите результат выполнения многопоточного кода"

### Чек-лист качественной задачи

- [ ] Реалистичный сценарий
- [ ] Четкие требования
- [ ] Тестовые данные
- [ ] Ожидаемый результат
- [ ] Критерии оценки
- [ ] Подсказки для интервьюера
- [ ] Дополнительные вопросы
- [ ] Варианты усложнения

## Шаблон для генерации новой задачи

```markdown
## Задача: [Название]

**Категория**: [Stream API | SQL | etc.]
**Уровень**: [1-5]
**Время**: [5-30 минут]

### Условие
[Описание задачи с контекстом]

### Входные данные
```java
// Пример входных данных
```

### Требования
1. [Требование 1]
2. [Требование 2]
3. [Дополнительное требование для Senior]

### Ожидаемый результат
```java
// Пример вывода
```

### Критерии оценки
- **Junior**: [базовое решение]
- **Middle**: [+ оптимизация]
- **Senior**: [+ обработка edge cases и best practices]

### Подводные камни
- [Типичная ошибка 1]
- [Неочевидный кейс 2]

### Follow-up вопросы
1. Как оптимизировать?
2. Как обработать null?
3. Как сделать thread-safe?
```